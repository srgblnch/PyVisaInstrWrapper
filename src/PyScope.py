#!/usr/bin/env python2.5

#=============================================================================
#
# file :        PyScope.py
#
# description : Python source for the Scope and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                Scope are implemented in this file.
#
# project :     TANGO Device Server
#
# Author: sblanch (main developer)
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    Cells / Alba Synchrotron
#               Cerdanyola/Bellaterra
#               Spain
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#
# This file is part of Tango-ds project.
#
# Tango-ds project is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Tango-ds project is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#=============================================================================


import PyTango
import sys
#from tau.core.utils import containers
import time
import remoteCommandsScope
#from PyTango_utils.dynamic import *
import struct
import numpy

from cStringIO import StringIO #For goodly fast str concat

import threadVisa
from threadVisa import group,cutlongstrings

class ScalarAttributeList(PyTango.Attr):#For ScaleChN,OffsetChN,...
    pass

class SpectrumAttributeList(PyTango.SpectrumAttr):#For ChannelN
    pass


#==================================================================
#   Scope Class Description:
#
#         A device server (as generic as possible) to control scopes on Tango Control System.
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :
#   DevState.OFF :
#   DevState.FAULT :
#==================================================================


class Scope(PyTango.Device_4Impl,threadVisa.ThreadVisa):

    #--------- Add you global variables here --------------------------


    def read_method(self,key):
        """ will be used with the threaded dict
        """
        if key.isalpha():
            return self.ask(self.query(key))
        else:
            i = 0
            while i <= len(key):
                if key[i:].isdigit():
                    return self.ask(self.query(key[:i],key[i:]))
                    break
                i += 1


    def write_method(self,key,Value):
        """ will be used with the threaded dict
        """
        if key.isalpha():
            return self.write(self.send(key))
        else:
            i = 0
            while i <= len(key):
                if key[i:].isdigit():
                    return self.write(self.send(key[:i],key[i:]))
                    break
                i += 1

    def link2dict(self):
        try:
            #self.visaDict = containers.RankedThreadDict()
            self.idn = self.ask("*IDN?")
        except Exception,e:
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            self.fatal_stream("In %s::link2dict(): IDN link2dict: %s"\
                             %(self.get_name(),e))
            return
        try:
            company,model,serial,firmware = self.idn.split(",")
            self.info_stream("\nScope characteristics:\n"\
                              "\tManufacturer: %s\n"\
                              "\tModel: %s\n"\
                              "\tSerial: %s\n"\
                              "\tFirmware: %s"%(company,model,serial,firmware))
            self.instructionSet = {
                'agilent technologies': remoteCommandsScope.Agilent,
                'tektronix': remoteCommandsScope.Tektronix,
            }[company.lower()](debug=True)
        except Exception,e:
            self.error_stream("In %s::link2dict() Exception: %s"\
                              %(self.get_name(),e))
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus("The device has not been able to get the "\
                                 "instructions set (hint: if the manufacturer "\
                                 "is supported, check %s is exported and try "\
                                 "init this device)"%self.PyVisaDS)
            return
        try:
            self.write(self.instructionSet.stop())
            OpCompl =self.ask(self.instructionSet.operationComplete())
            if not OpCompl:
                self.warn_stream("In %s::link2dict(): The scope is not free to"\
                                 " be used"%self.get_name())
                self.set_state(PyTango.DevState.FAULT)
                e[0]['desc'] = "The scope is not free to be used."
                self.exceptionStatus(e)
                return
            self.write(self.instructionSet.run())
            if self.LockInstrument:
                self.Lock()
            self.__checkOpenChannels()
            self.__checkOnFunctions()
            self.__SetSendvalidFlag()
        except Exception,e:
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            self.error_stream("In %s::link2dict() Exception %s"\
                              %(self.get_name(),e))


    def __checkOpenChannels(self):
        try:
            #query about the channels on/off status
            if self.NumChannels > 0:
                output = StringIO()
                for i in range(self.NumChannels):
                    output.write(self.instructionSet.query("State",i+1)+";")
                _channelDisplay = self.ask(output.getvalue()).split(";")
                self.isChannelOpen = {}
                for i in range(self.NumChannels):
                    self.isChannelOpen[i+1] = bool(int(_channelDisplay[i]))
        except Exception,e:
            self.error_stream("In %s::__checkOpenChannels() Exception %s"\
                              %(self.get_name(),e))

    def __checkOnFunctions(self):
        try:
            #query about the function on/off status
            if self.NumFunctions > 0:
                output = StringIO()
                for i in range(self.NumFunctions):
                    output.write(self.instructionSet.query("StateFn",i+1)+";")
                _functionDisplay = self.ask(output.getvalue()).split(";")
                self.isFunctionOn = {}
                for i in range(self.NumFunctions):
                    self.isFunctionOn[i+1] = bool(int(_functionDisplay[i]))
        except Exception,e:
            self.error_stream("In %s::__checkOnFunctions() Exception %s"\
                              %(self.get_name(),e))

    def __SetSendvalidFlag(self):
        try:
            self.instructionSet.send("sendvalid",value=True)
        except Exception,e:
            self.error_stream("In %s::__SetSendvalidFlag() Exception %s"\
                              %(self.get_name(),e))

    """ The first part of the input is the value, the second the validity 
        that the scope gives """
    def __postProcess(self,input):
        self.debug_stream("In %s::__postProcess(%s)"%(self.get_name(),str(input)))
        try:
            output = float(input.split(",")[0])
        except:
            try:
                output = float(input)
            except:
                return float('nan')
        if input == '+99E+36' or output == 9.99999e37:
            #raise AttributeError,"Value out of the range"
            return float('nan')
        return output


#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.__visaScope = None
        Scope.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.info_stream("In %s::delete_device()"%self.get_name())
        try:
            self.Unlock()
        except Exception,e:
            self.warn_stream("Ohh! %s"%e)
        self.stopThread()
        self.set_state(PyTango.DevState.OFF)
        self.exceptionStatus()


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.debug_stream("In %s::init_device()"%self.get_name())
        self.set_state(PyTango.DevState.INIT)
        self.exceptionStatus()
        self.get_device_properties(self.get_device_class())
        #setup the QueryWindow attr
        self._queryWindow = 1
        multiattr = self.get_device_attr()
        wattr = multiattr.get_w_attr_by_name('QueryWindow')
        wattr.set_write_value(self._queryWindow)
        #setup the TimeStampsThreshold attr
        self._timeStampsThreshold = 1.0
        multiattr = self.get_device_attr()
        wattr = multiattr.get_w_attr_by_name('TimeStampsThreshold')
        wattr.set_write_value(self._timeStampsThreshold)
        #logger
        try:
            self.logger_maxlen = int(self.logger_maxlen)
            if self.logger_maxlen < 1: self.logger_maxlen = 1000
        except Exception,e:
            self.debug_stream("In %s::init_device(): Invalid \"logger_maxlen\" "\
                              "property value. Setting to default "\
                              "logger_maxlen=1000"%self.get_name())
            self.warn_stream("In %s::init_device(): Exception: %s"\
                              %(self.get_name(),e))
            self.logger_maxlen = 1000
        self.info_stream("In %s::init_device(): LOGGER_maxlen property set to "\
                         "%d"%(self.get_name(),self.logger_maxlen))
        #channels
        try:
            self.info_stream("In %s::init_device(): Configuring the scope "\
                             "device for %s Channels."\
                             %(self.get_name(),self.NumChannels))
            self.NumChannels = int(self.NumChannels)
        except Exception,e:
            self.debug_stream("In %s::init_device(): Invalid \"NumChannels\" "\
                              "property value. Setting to default NumChannels=4"\
                              %self.get_name())
            self.error_stream("In %s::init_device(): Exception: %s"\
                              %(self.get_name(),e))
            self.NumChannels = 4
        #functions
        try:
            self.info_stream("In %s::init_device(): Configuring the scope "\
                             "device for %s Functions."\
                             %(self.get_name(),self.NumFunctions))
            self.NumFunctions = int(self.NumFunctions)
        except Exception,e:
            self.debug_stream("In %s::init_device(): Invalid \"NumFunctions\" "\
                              "property value. Setting to default NumFunctions=0"\
                              %self.get_name())
            self.error_stream("In %s::init_device(): Exception: %s"\
                              %(self.get_name(),e))
            self.NumFunctions = 0
        #PyVisaDS
        self.info_stream("In %s::init_device(): Property for the 'Remote "\
                         "PyVisa device' in set, connecting to the device %s"\
                         %(self.get_name(),self.PyVisaDS))
        #Lock
        try:
            self.LockInstrument = bool(self.LockInstrument)
            self.info_stream("In %s::init_device(): LockInstrument property "\
                             "= %s"%(self.get_name(),self.LockInstrument))
        except Exception,e:
            self.LockInstrument = True
            self.error_stream("In %s::init_device(): Invalid \"LockInstrument\""\
                              " property value. Setting to default, True"\
                              %(self.get_name()))
        #connect
        try:
            self.startThread(1)
            self.__readAttributes = {}
            self.__readAttributes['ScaleH'] = None
            self.__readAttributes['ScaleH_timestamp'] = None
            self.__readAttributes['OffsetH'] = None
            self.__readAttributes['OffsetH_timestamp'] = None
            self.__readAttributes['CurrentSampleRate'] = None
            self.__readAttributes['CurrentSampleRate_timestamp'] = None
            self.__readAttributes['TriggerType'] = None
            self.__readAttributes['TriggerType_timestamp'] = None
            self.__readAttributes['WaveformDataFormat'] = None
            self.__readAttributes['WaveformDataFormat_timestamp'] = None
            self.__readAttributes['AcquisitionMode'] = None
            self.__readAttributes['AcquisitionMode_timestamp'] = None
            self.__readAttributes['AcquisitionPoints'] = None
            self.__readAttributes['AcquisitionPoints_timestamp'] = None

        except Exception,e:
            self.error_stream("In %s::init_device(): PyVisaDS not available."\
                              " Exception: %s"%(self.get_name(),e))
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            return

        #done
        self.set_state(PyTango.DevState.ON)
        self.exceptionStatus()


#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In %s::always_excuted_hook()"%self.get_name())


#==================================================================
#
#    Scope read/write attribute methods
#
#==================================================================


#??    @TraceIt
    def dyn_attr(self):
        self.debug_stream("In %s::dyn_attr()"%self.get_name())
        self.channelDynamicAttributes()
        if self.NumFunctions > 0:
            self.functionDynamicAttributes()

    def channelDynamicAttributes(self):
        self.debug_stream("In %s::channelDynamicAttributes()"%self.get_name())
        #remember: "Channel" is for the 1D with the signal.
        #          Particular measurements per channel have the "Ch" infix.
        #          The common attr like horizontal things, are not dynamic and 
        #          they must not contain this letters in the attr name.
    
        RWattributes = {#'key':[datatype,readMethod,writeMethod]
                        'Scale': [PyTango.DevDouble,
                                  Scope.read_ScaleChN,
                                  Scope.write_ScaleChN],
                        'Offset':[PyTango.DevDouble,
                                  Scope.read_OffsetChN,
                                  Scope.write_OffsetChN],
                       }
        ROattributes = {#'key':[datatype,readMethod]
                        'Amplitude':   [PyTango.DevDouble,
                                        Scope.read_AmplitudeChN],
                        'VPeakToPeak': [PyTango.DevDouble,
                                        Scope.read_VPeakToPeakChN],
                        'VoltageMax':  [PyTango.DevDouble,
                                        Scope.read_VoltageMaxChN],
                        'VoltageMin':  [PyTango.DevDouble,
                                        Scope.read_VoltageMinChN],
                        'VoltageUpper':[PyTango.DevDouble,
                                        Scope.read_VoltageUpperChN],
                        'VoltageLower':[PyTango.DevDouble,
                                        Scope.read_VoltageLowerChN],
                        'RiseTime':    [PyTango.DevDouble,
                                        Scope.read_RiseTimeChN],
                        'FallTime':    [PyTango.DevDouble,
                                        Scope.read_FallTimeChN],
                        'Period':      [PyTango.DevDouble,
                                        Scope.read_PeriodChN],
                        'Frequency':   [PyTango.DevDouble,
                                        Scope.read_FrequencyChN],
                        'OverShoot':   [PyTango.DevDouble,
                                        Scope.read_OverShootChN],
                        'PreShoot':    [PyTango.DevDouble,
                                        Scope.read_PreShootChN],
                        'Impedance':   [PyTango.DevDouble,
                                        Scope.read_ImpedanceChN],
                        'State':       [PyTango.DevBoolean,
                                        Scope.read_StateChN],
                       }

        # The main method used here:
        # self.add_attribute(self, attr, r_meth = None, w_meth = None, is_allo_meth = None)
        for i in range(1,self.NumChannels+1):
            for element in RWattributes:
                attr_name = "%sCh%d"%(element,i)
                attr = PyTango.Attr(attr_name,RWattributes[element][0],\
                                    PyTango.READ_WRITE)
                self.add_attribute(attr,\
                                   r_meth = RWattributes[element][1],\
                                   w_meth = RWattributes[element][2],\
                                   is_allo_meth = Scope.is_genericDynAttr_allowed)
                self.debug_stream("In %s::channelDynamicAttributes() add rw attr: %s"\
                                  %(self.get_name(),attr_name))
                self.__readAttributes[attr_name] = None
                self.__readAttributes[attr_name+"_timestamp"] = None
            for element in ROattributes:
                attr_name = "%sCh%d"%(element,i)
                attr = PyTango.Attr(attr_name,ROattributes[element][0],\
                                    PyTango.READ)
                self.add_attribute(attr,\
                                   r_meth = ROattributes[element][1],\
                                   is_allo_meth = Scope.is_genericDynAttr_allowed)
                #TODO: some attr may need to send events, but not all of them by default
                #self.set_change_event(attr_name, True, False)
                self.debug_stream("In %s::channelDynamicAttributes() add ro attr: %s"\
                                  %(self.get_name(),attr_name))
                self.__readAttributes[attr_name] = None
                self.__readAttributes[attr_name+"_timestamp"] = None

            attr_name = "Channel%d"%i
            attr = PyTango.SpectrumAttr(attr_name,PyTango.DevDouble,\
                                        PyTango.READ,40000000)#400KSamples!=40GSamples
            self.add_attribute(attr,\
                               r_meth = Scope.read_ChannelN,\
                               is_allo_meth = Scope.is_genericDynAttr_allowed)
            
            self.debug_stream("In %s::channelDynamicAttributes() add attr: %s"\
                              %(self.get_name(),attr_name))
            #spectrum excuded from self.__readAttributes, by now

    def functionDynamicAttributes(self):
        self.debug_stream("In %s::functionDynamicAttributes()"%self.get_name())
        #Function dynamic attributes
        #RWattributes = {#'key':[datatype,readMethod,writeMethod]
        #               } #Not yet rw attributes
        ROattributes = {#'key':[datatype,readMethod]
                        'Amplitude':   [PyTango.DevDouble,
                                        Scope.read_AmplitudeFnN],
                        'VoltageMax':  [PyTango.DevDouble,
                                        Scope.read_VoltageMaxFnN],
                        'VoltageMin':  [PyTango.DevDouble,
                                        Scope.read_VoltageMinFnN],
                        'VPeakToPeak': [PyTango.DevDouble,
                                        Scope.read_VPeakToPeakFnN],
                        'State':       [PyTango.DevBoolean,
                                        Scope.read_StateFnN],
                       }
        for i in range(1,self.NumFunctions+1):
            #for element in RWattributes:
                #not yet write attributes
            for element in ROattributes:
                attr_name = "%sFn%d"%(element,i)
                attr = PyTango.Attr(attr_name,ROattributes[element][0],\
                                    PyTango.READ)
                self.add_attribute(attr,\
                                   r_meth = ROattributes[element][1],\
                                   is_allo_meth = Scope.is_genericDynAttr_allowed)
                #TODO: some attr may need to send events, but not all of them by default
                #self.set_change_event(attr_name,True,False)
                self.debug_stream("In %s::functionDynamicAttributes() add ro attr: %s"\
                                  %(self.get_name(),attr_name))
                self.__readAttributes[attr_name] = None
                self.__readAttributes[attr_name+"_timestamp"] = None

    def preMultiattributeQuery(self,multiattr,data):
        """Build the concatenation of queries for visa"""
        try:
            self.debug_stream("In %s::preMultiattributeQuery()"%self.get_name())
            supported_attrs = []
            unsupported_attrs = []
            concatenated_query = ""
            for attr_index in data:
                attr = multiattr.get_attr_by_ind(attr_index)
                attr_name = attr.get_name()
                #if attr_name.startswith("Channel"): #one of the spectrum data
                #    pass #by now, nothing to do where
                #else: #here should be only the scalars
                split_attr = attr_name.split("Ch")
                if len(split_attr) == 2:
                    ch_n = int(split_attr[1])
                    particular_query = self.instructionSet.query(split_attr[0],ch_n)
                elif len(split_attr) == 1:
                    split_attr = attr_name.split("Fn")
                    if len(split_attr) == 2:
                        func_n = int(split_attr[1])
                        particular_query = self.instructionSet.query(split_attr[0]+"Fn",func_n)
                    else:
                        particular_query = self.instructionSet.query(split_attr[0])
                else: raise Exception("Not possible to prepare the query!") #this should never happen
                if (not particular_query == None) and len(particular_query) > 0:
                    #print "+%d:%s"%(attr_index,particular_query)
                    supported_attrs.append(attr_index)
                    concatenated_query = "%s;%s"%(concatenated_query,particular_query)
                else:
                    unsupported_attrs.append(attr_index)
            concatenated_query = concatenated_query[1:]#remove the first ";"
            self.debug_stream("In %s::preMultiattributeQuery() final subset %s (unsupporteds %s)"%(self.get_name(),supported_attrs,unsupported_attrs))
            return supported_attrs,concatenated_query,unsupported_attrs
        except Exception,e:
            self.error_stream("In %s::preMultiattributeQuery() Exception: %s"\
                              %(self.get_name(),e))
            return None,None,None

    def postMultiattributeQuery(self,answers,multiattr,data,timestamp,unsupported_attrs):
        """Organize the answer of a query into a dictionary"""
        try:
            self.debug_stream("In %s::postMultiattributeQuery()"%self.get_name())
            for attr_seq,attr_index in enumerate(data):
                attr = multiattr.get_attr_by_ind(attr_index)
                attr_name = attr.get_name()
                #print("for attr %s answer is %s"%(attr_name,answers[attr_seq]))
                self.__readAttributes[attr_name] = answers[attr_seq] or 'nan'
                self.__readAttributes[attr_name+"_timestamp"] = timestamp
                self.debug_stream("In %s::postMultiattributeQuery() attr answered: %s = %s"%(self.get_name(),attr_name,answers[attr_seq]))
            for attr_seq,attr_index in enumerate(unsupported_attrs):
                attr = multiattr.get_attr_by_ind(attr_index)
                attr_name = attr.get_name()
                self.__readAttributes[attr_name] = float('-inf')#mark for exception
                self.debug_stream("In %s::postMultiattributeQuery() attr excepted: %s"%(self.get_name(),attr_name))
        except Exception,e:
            self.error_stream("In %s::postMultiattributeQuery() Exception: %s"%\
                              (self.get_name(),e))

    def filterAttributes(self,multiattr,data):
        try:
            self.debug_stream("In %s::filterAttributes(%s)"%(self.get_name(),data))
            #global for the non hardware attributes
            nonHwAttr = []
            nonHwAttr.append(multiattr.get_attr_ind_by_name('QueryWindow'))
            nonHwAttr.append(multiattr.get_attr_ind_by_name('TimeStampsThreshold'))
            #global for the cached data
            currentTime = time.time()
            #container for the return vector
            res = PyTango.StdLongVector()
            for attr_index in data:
                attr_name = multiattr.get_attr_by_ind(attr_index).get_name()
                #Exclude the non hardware attributes
                if attr_index in nonHwAttr:
                    self.debug_stream("In %s::filterAttributes() excluding (nonHwAttr) %s"%\
                                      (self.get_name(),attr_name))
                #Exclude the spectrum attributes
                elif attr_name.startswith("Channel"):
                    self.debug_stream("In %s::filterAttributes() excluding (ch) %s"%\
                                      (self.get_name(),attr_name))
                #Exclude the cached and not too old values
                elif (not self.__readAttributes[attr_name] == None) and \
                   (not self.__readAttributes[attr_name+"_timestamp"] < currentTime-self._timeStampsThreshold):
                    self.debug_stream("In %s::filterAttributes() excluding (ts) %s"%\
                                      (self.get_name(),attr_name))
                #Include in the final list to query to the hardware
                else:
                    self.debug_stream("In %s::filterAttributes() including %s to hardware read"%\
                                      (self.get_name(),attr_name))
                    res.append(attr_index)
            return res
        except Exception,e:
            self.error_stream("In %s::filterAttributes(%s) Exception: %s"%(self.get_name(),data,e))
            return None

#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        #FIXME: better use of the string concatenation would be need
        self.debug_stream("In %s::read_attr_hardware()"%self.get_name())
        multiattr = self.get_device_attr()
        data = self.filterAttributes(multiattr, data)
        if data == None or len(data) == 0:
            self.debug_stream("In %s::read_attr_hardware() nothing to read in hardware"%(self.get_name()))
            return #if the filters says that no hw read is need
        data_grouped = group(data,self._queryWindow)
        self.info_stream("In %s::read_attr_hardware() data grouped: %s"%(self.get_name(),data_grouped))
        if len(data_grouped) > 0:
            for subdata in data_grouped:
                if len(subdata) > 0:
                    if not type(subdata) in [list,tuple]: subdata = [subdata]
                    if type(subdata) is tuple: subdata = list(subdata)
                    self.debug_stream("In %s::read_attr_hardware() subgroup %s"%(self.get_name(),subdata))
                    subdata,query,attr_except = self.preMultiattributeQuery(multiattr,subdata)
                    self.fixVisaAttrs()
                    if (not query == None) and len(query) > 0:
                        answers = self.ask(query).split(";")
                        timestamp = time.time()
                        self.postMultiattributeQuery(answers,multiattr,subdata,timestamp,attr_except)

#------------------------------------------------------------------
#    Read StateChN attribute
#------------------------------------------------------------------
    def read_StateChN(self, attr):
        self.debug_stream("In %s::read_StateChN()"%self.get_name())
        
        #    Add your own code here
        #self.info_stream(attr.get_name())
        #self.info_stream(attr.get_name().split("Ch"))
        chNum = int(attr.get_name().split("Ch")[1])
#        _channelDisplay = bool(int(self.ask(self.instructionSet.query("channelDisplay",\
#                                                          ch=chNum)+"?")))
        _channelDisplay = bool(int(self.__readAttributes[attr.get_name()]))
        #print("_channelDisplay: %s"%_channelDisplay)
        self.isChannelOpen[chNum] = _channelDisplay
        #print("self.isChannelOpen[chNum]: %s"%self.isChannelOpen[chNum])
        attr.set_value_date_quality(_channelDisplay,\
                                    self.__readAttributes[attr.get_name()+"_timestamp"],\
                                    PyTango.AttrQuality.ATTR_VALID)

#------------------------------------------------------------------
#    Read StateFnN attribute
#------------------------------------------------------------------
    def read_StateFnN(self, attr):
        self.debug_stream("In %s::read_StateFnN()"%self.get_name())
        
        #    Add your own code here
        #self.info_stream(attr.get_name())
        #self.info_stream(attr.get_name().split("Ch"))
        funcNum = int(attr.get_name().split("Fn")[1])
        _functionDisplay = bool(int(self.__readAttributes[attr.get_name()]))
        #print("_functionDisplay: %s"%_functionDisplay)
        self.isFunctionOn[funcNum] = _functionDisplay
        #print("self.isFunctionOn[chNum]: %s"%self.isFunctionOn[funcNum])
        attr.set_value_date_quality(_functionDisplay,\
                                    self.__readAttributes[attr.get_name()+"_timestamp"],\
                                    PyTango.AttrQuality.ATTR_VALID)

#------------------------------------------------------------------
#    Read read_AmplitudeChN dyn_attribute
#------------------------------------------------------------------
    def read_AmplitudeChN(self, attr):
        self.debug_stream("In %s::read_AmplitudeChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_amplitude = self.ask(self.instructionSet.query("amplitude",chNum))
            _amplitude = self.__readAttributes[attr.get_name()]
            if not _amplitude == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_amplitude),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_AmplitudeFnN dyn_attribute
#------------------------------------------------------------------
    def read_AmplitudeFnN(self, attr):
        self.debug_stream("In %s::read_AmplitudeFnN()"%self.get_name())
        
        #    Add your own code here
        funcNum = int(attr.get_name().split("Fn")[1])
        if self.isFunctionOn[funcNum]:
            _amplitude = self.__readAttributes[attr.get_name()]
            if not _amplitude == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_amplitude),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, function %d is not on"%funcNum

#------------------------------------------------------------------
#    Read read_VPeakToPeakChN dyn_attribute
#------------------------------------------------------------------
    def read_VPeakToPeakChN(self, attr):
        self.debug_stream("In %s::read_VPeakToPeakChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_amplitude = self.ask(self.instructionSet.query("amplitude",chNum))
            _vpp = self.__readAttributes[attr.get_name()]
            if not _vpp == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_vpp),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VPeakToPeakFnN dyn_attribute
#------------------------------------------------------------------
    def read_VPeakToPeakFnN(self, attr):
        self.debug_stream("In %s::read_VPeakToPeakFnN()"%self.get_name())
        
        #    Add your own code here
        funcNum = int(attr.get_name().split("Fn")[1])
        if self.isFunctionOn[funcNum]:
            _vpp = self.__readAttributes[attr.get_name()]
            if not _vpp == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_vpp),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, function %d is not on"%funcNum

#------------------------------------------------------------------
#    Read read_VoltageMaxChN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageMaxChN(self, attr):
        self.debug_stream("In %s::read_VoltageMaxChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_voltageMax = self.ask(self.instructionSet.query("voltageMax",chNum))
            _voltageMax = self.__readAttributes[attr.get_name()]
            if not _voltageMax == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageMax),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VoltageMaxFnN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageMaxFnN(self, attr):
        self.debug_stream("In %s::read_VoltageMaxFnN()"%self.get_name())
        
        #    Add your own code here
        funcNum = int(attr.get_name().split("Fn")[1])
        if self.isFunctionOn[funcNum]:
            #_voltageMax = self.ask(self.instructionSet.query("voltageMax",chNum))
            _voltageMax = self.__readAttributes[attr.get_name()]
            if not _voltageMax == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageMax),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, function %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VoltageMinChN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageMinChN(self, attr):
        self.debug_stream("In %s::read_VoltageMinChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_voltageMin = self.ask(self.instructionSet.query("voltageMin",chNum))
            _voltageMin = self.__readAttributes[attr.get_name()]
            if not _voltageMin == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageMin),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VoltageMinFnN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageMinFnN(self, attr):
        self.debug_stream("In %s::read_VoltageMinFnN()"%self.get_name())
        
        #    Add your own code here
        funcNum = int(attr.get_name().split("Fn")[1])
        if self.isFunctionOn[funcNum]:
            #_voltageMin = self.ask(self.instructionSet.query("voltageMin",chNum))
            _voltageMin = self.__readAttributes[attr.get_name()]
            if not _voltageMin == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageMin),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, function %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VoltageUpperChN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageUpperChN(self, attr):
        self.debug_stream("In %s::read_VoltageUpperChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_voltageUpper = self.ask(self.instructionSet.query("voltageUpper",chNum))
            _voltageUpper = self.__readAttributes[attr.get_name()]
            if not _voltageUpper == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageUpper),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_VoltageLowerChN dyn_attribute
#------------------------------------------------------------------
    def read_VoltageLowerChN(self, attr):
        self.debug_stream("In %s::read_VoltageLowerChN()"%self.get_name())
        
        #    Add your own code here
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_voltageLower = self.ask(self.instructionSet.query("voltageLower",chNum))
            _voltageLower = self.__readAttributes[attr.get_name()]
            if not _voltageLower == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_voltageLower),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read ScaleChN dyn_attribute
#------------------------------------------------------------------
    def read_ScaleChN(self, attr):
        self.debug_stream("In %s::read_ScaleChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_scale = self.ask(self.instructionSet.query("scale",chNum))
            _scale = self.__readAttributes[attr.get_name()]
            if not _scale == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_scale),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Write ScaleChN dyn_attribute
#------------------------------------------------------------------
    def write_ScaleChN(self, attr):
        self.debug_stream("In %s::write_ScaleChN()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s"%data)

        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            self.write(self.instructionSet.send("scale",chNum,data[0]))
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read OffsetChN dyn_attribute
#------------------------------------------------------------------
    def read_OffsetChN(self, attr):
        self.debug_stream("In %s::read_OffsetChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_offset = self.ask(self.instructionSet.query("offset",chNum))
            _offset = self.__readAttributes[attr.get_name()]
            if not _offset == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_offset),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Write OffsetChN attribute
#------------------------------------------------------------------
    def write_OffsetChN(self, attr):
        self.debug_stream("In %s::write_OffsetChN()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s"%data)

        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            self.write(self.instructionSet.send("offset",chNum,data[0]))
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_RiseTimeChN dyn_attribute
#------------------------------------------------------------------
    def read_RiseTimeChN(self, attr):
        self.debug_stream("In %s::read_RiseTimeChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_risetime = self.ask(self.instructionSet.query("risetime",chNum))
            _risetime = self.__readAttributes[attr.get_name()]
            if not _risetime == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_risetime),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_FallTimeChN dyn_attribute
#------------------------------------------------------------------
    def read_FallTimeChN(self, attr):
        self.debug_stream("In %s::read_FallTimeChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_falltime = self.ask(self.instructionSet.query("falltime",chNum))
            _falltime = self.__readAttributes[attr.get_name()]
            if not _falltime == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_falltime),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_PeriodChN dyn_attribute
#------------------------------------------------------------------
    def read_PeriodChN(self, attr):
        self.debug_stream("In %s::read_PeriodChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_period = self.ask(self.instructionSet.query("period",chNum))
            _period = self.__readAttributes[attr.get_name()]
            if not _period == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_period),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_FrequencyChN dyn_attribute
#------------------------------------------------------------------
    def read_FrequencyChN(self, attr):
        self.debug_stream("In %s::read_FrequencyChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_frequency = self.ask(self.instructionSet.query("frequency",chNum))
            _frequency = self.__readAttributes[attr.get_name()]
            if not _frequency == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_frequency),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_OverShootChN dyn_attribute
#------------------------------------------------------------------
    def read_OverShootChN(self, attr):
        self.debug_stream("In %s::read_OverShootChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_overshoot = self.ask(self.instructionSet.query("overshoot",chNum))
            _overshoot = self.__readAttributes[attr.get_name()]
            if not _overshoot == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_overshoot),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_PreShootChN dyn_attribute
#------------------------------------------------------------------
    def read_PreShootChN(self, attr):
        self.debug_stream("In %s::read_PreShootChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
            #_preshoot = self.ask(self.instructionSet.query("preshoot",chNum))
            _preshoot = self.__readAttributes[attr.get_name()]
            if not _preshoot == float('-inf'):
                attr.set_value_date_quality(self.__postProcess(_preshoot),\
                                            self.__readAttributes[attr.get_name()+"_timestamp"],\
                                            PyTango.AttrQuality.ATTR_VALID)
            else:
                raise AttributeError,"Not supported by this manufacturer and/or model"
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read read_ImpedanceChN dyn_attribute
#------------------------------------------------------------------
    def read_ImpedanceChN(self, attr):
        self.debug_stream("In %s::read_ImpedanceChN()"%self.get_name())
        
        #    Add your own code here
        
        chNum = int(attr.get_name().split("Ch")[1])
        if self.isChannelOpen[chNum]:
#            _impedance = self.ask(self.instructionSet.query("impedance",\
#                                                                  chNum))
            _impedance = self.__readAttributes[attr.get_name()]
            try:
                _impedance_f = float(_impedance)
            except:
                if _impedance in ["DC50","DCFifty"]:
                    _impedance_f = 50.0
#                elif _impedance in [ONEM]:
#                    _impedance_f = inf
                else:
                    _impedance_f = float('nan')
            attr.set_value_date_quality(_impedance_f,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum



#------------------------------------------------------------------
#    Read ScaleH attribute
#------------------------------------------------------------------
    def read_ScaleH(self, attr):
        self.debug_stream("In %s::read_ScaleH()"%self.get_name())
        
        #    Add your own code here
        
        #attr_ScaleH_read = float(self.ask(self.instructionSet.query("scaleH")))
        attr_ScaleH_read = float(self.__readAttributes[attr.get_name()])
        if not attr_ScaleH_read == float('-inf'):
            attr.set_value_date_quality(attr_ScaleH_read,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#------------------------------------------------------------------
#    Write ScaleH attribute
#------------------------------------------------------------------
    def write_ScaleH(self, attr):
        self.debug_stream("In %s::write_ScaleH()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_ScaleH(): Attribute value = %f"\
                          %(self.get_name(),data[0]))

        #    Add your own code here
        scpi = self.instructionSet.send("ScaleH",value=data[0])
        print "scpi ",scpi
        self.write(scpi)


#---- ScaleH attribute State Machine -----------------
    def is_ScaleH_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read OffsetH attribute
#------------------------------------------------------------------
    def read_OffsetH(self, attr):
        self.debug_stream("In %s::read_OffsetH()"%self.get_name())
        
        #    Add your own code here
        
        #attr_OffsetH_read = float(self.ask(self.instructionSet.query("OffsetH")))
        attr_OffsetH_read = float(self.__readAttributes[attr.get_name()])
        if not attr_OffsetH_read == float('-inf'):
            attr.set_value_date_quality(attr_OffsetH_read,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#------------------------------------------------------------------
#    Write OffsetH attribute
#------------------------------------------------------------------
    def write_OffsetH(self, attr):
        self.debug_stream("In %s::write_OffsetH()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_OffsetH(): Attribute value = %f"\
                          %(self.get_name(),data[0]))

        #    Add your own code here
        
        self.write(self.instructionSet.send("OffsetH",value=data[0]))


#---- OffsetH attribute State Machine -----------------
    def is_OffsetH_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read CurrentSampleRate attribute
#------------------------------------------------------------------
    def read_CurrentSampleRate(self, attr):
        self.debug_stream("In %s::read_CurrentSampleRate()"%self.get_name())
        
        #    Add your own code here
        #_currentSampleRate = float(self.ask(self.instructionSet.query("currentSampleRate")))
        _currentSampleRate = float(self.__readAttributes[attr.get_name()])
        if not _currentSampleRate == float('-inf'):
            attr.set_value_date_quality(_currentSampleRate,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#---- CurrentSampleRate attribute State Machine -----------------
    def is_CurrentSampleRate_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read TriggerType attribute
#------------------------------------------------------------------
    def read_TriggerType(self, attr):
        self.debug_stream("In %s::read_TriggerType()"%self.get_name())
        
        #    Add your own code here
        
        #_triggerType = self.ask(self.instructionSet.query("triggerType"))
        _triggerType = self.__readAttributes[attr.get_name()]
        if not _triggerType == float('-inf'):
            attr.set_value_date_quality(_triggerType,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#---- TriggerType attribute State Machine -----------------
    def is_TriggerType_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


##------------------------------------------------------------------
##    Read WaveformFormat attribute
##------------------------------------------------------------------
#    def read_WaveformFormat(self, attr):
#        self.debug_stream("In %s::read_WaveformFormat()"%self.get_name())
#        
#        #    Add your own code here
#        attr.set_value(self.ask(self.instructionSet.query("channel_format")))
#
#
##------------------------------------------------------------------
##    Write WaveformFormat attribute
##------------------------------------------------------------------
#    def write_WaveformFormat(self, attr):
#        self.debug_stream("In %s::write_WaveformFormat()"%self.get_name())
#        data=[]
#        attr.get_write_value(data)
#        self.debug_stream("Attribute value = %s"%data)
#
#        #    Add your own code here
#        self.write(self.instructionSet.send("channel_format",data[0]))
#
#
##---- WaveformFormat attribute State Machine -----------------
#    def is_WaveformFormat_allowed(self, req_type):
#        if self.get_state() in [PyTango.DevState.FAULT]:
#            #    End of Generated Code
#            #    Re-Start of Generated Code
#            return False
#        return True


#------------------------------------------------------------------
#    Read ChannelN dyn_attribute
#------------------------------------------------------------------
    def read_ChannelN(self, attr):
        self.debug_stream("In %s::read_ChannelN()"%self.get_name())
        
        #    Add your own code here

        chNum = int(attr.get_name().split("Channel")[1])
        if self.isChannelOpen[chNum]:
            prepare,query = self.instructionSet.query("Channel",chNum).rsplit(";",1)
            

            if self.__readAttributes['WaveformDataFormat'] == None:
                self.__readAttributes['WaveformDataFormat'] = self.ask(self.instructionSet.query("WaveformDataFormat"))
                self.__readAttributes['WaveformDataFormat_timestamp'] = time.time()
            if self.__readAttributes["WaveformDataFormat"].startswith('ASC'):
                #directly the answer from ask_for_values() is the expected data type
                attr_ChannelN_read = self.ask_for_values(prepare+";"+query)
            else:
                # in binary format case, is necessary to convert to integers
                # and later expand it to convert to floats
                # FIXME: This code looks correct, but the signal ploted doesn't
                #        and needs to be reviewed
                try:
                    if self.__readAttributes['WaveformDataFormat'].startswith('WORD'):
                        #make sure that it is little endian attaching it to 
                        #the query as a preconfiguration
                        prepare = "%s;%s"%(prepare,self.instructionSet.send('ByteOrder',value="LSBF"))
                    query = "%s;%s;%s"%(self.instructionSet.query('WaveformOrigin'),
                                        self.instructionSet.query('WaveformIncr'),
                                        query)
                    #_waveform = self.ask(prepare+";"+query)
                    origin,incr,_waveform = self.ask(prepare+";"+query).split(';',2)#don't split more than twice
                    if not _waveform[0] == '#':
                        raise AttributeError,"Wrong data receiver from channel %d"%chNum
                    nBytesLengthBlock = int(_waveform[1])
                    nBytesWaveBlock = int(_waveform[2:nBytesLengthBlock+2])
                    waveBytes = _waveform[nBytesLengthBlock+2:nBytesWaveBlock]
                    
                    ####
                    #struct library version
                    if self.__readAttributes['WaveformDataFormat'].startswith('BYT'):
                        format = 'b'#signed char, 1byte
                        divisor = 1
                    elif self.__readAttributes['WaveformDataFormat'].startswith('WORD'):
                        format = 'h'#signed short, 2byte
                        divisor = 2
                    #FIXME: it looks that our scopes doesn't suport LONG format
                    #       what would mean that already the received data can 
                    #       be unpack into floats directly
                    else:
                        raise AttributeError,"Cannot decodify data receiver from channel %d"%chNum
                    nCompletBytes = len(waveBytes)-(len(waveBytes)%divisor)
                    if not len(waveBytes)%4 == 0:
                        self.debug_stream("nIncompleteBytes = %d"%(len(waveBytes)%divisor))
                    if not self.__readAttributes['WaveformDataFormat'].startswith('LON'):
                        #convert the received input to integers
                        unpackInt = struct.unpack(format*(nCompletBytes/divisor),waveBytes[:nCompletBytes])
                        #expand the input when each float is codified in less than 4 bytes
                    #    fourBytesInt = struct.pack('<'+'i'*len(unpackInt),*unpackInt[:len(unpackInt)])
                    #else:
                    #    fourBytesInt = waveBytes
                    #attr_ChannelN_read = struct.unpack('f'*(len(fourBytesInt)/4),fourBytesInt[:len(fourBytesInt)])
                    floats = numpy.array(unpackInt,dtype=float)
                    attr_ChannelN_read = (float(origin) + (float(incr) * floats))
                    # end struct library version
                    ####
                except Exception,e:
                    self.error_stream("In %s::read_ChannelN() Something wrong: %s"%(self.get_name(),e))
                    attr_ChannelN_read = numpy.array([])
            self.debug_stream("In %s::read_ChannelN() waveform= \"%s\" (%d points)"\
                              %(self.get_name(),
                                cutlongstrings(attr_ChannelN_read.tostring(),self.logger_maxlen),
                                len(attr_ChannelN_read)))
            attr.set_value(attr_ChannelN_read, len(attr_ChannelN_read))
        else:
            raise AttributeError,"Not allow, channel %d is not open"%chNum


#------------------------------------------------------------------
#    Read QueryWindow attribute
#------------------------------------------------------------------
    def read_QueryWindow(self, attr):
        self.debug_stream("In %s::read_QueryWindow()"%self.get_name())
        
        #    Add your own code here
        
        attr.set_value(int(self._queryWindow))


#------------------------------------------------------------------
#    Write QueryWindow attribute
#------------------------------------------------------------------
    def write_QueryWindow(self, attr):
        self.debug_stream("In %s::write_QueryWindow()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s"%data)

        #    Add your own code here
        
        self._queryWindow = int(data[0])

#------------------------------------------------------------------
#    Read TimeStampsThreshold attribute
#------------------------------------------------------------------
    def read_TimeStampsThreshold(self, attr):
        self.debug_stream("In %s::read_TimeStampsThreshold()"%self.get_name())
        
        #    Add your own code here
        
        attr.set_value(float(self._timeStampsThreshold))


#------------------------------------------------------------------
#    Write TimeStampsThreshold attribute
#------------------------------------------------------------------
    def write_TimeStampsThreshold(self, attr):
        self.debug_stream("In %s::write_TimeStampsThreshold()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("Attribute value = %s"%data)

        #    Add your own code here
        
        self._timeStampsThreshold = float(data[0])

####
#generic function for is_<attr>_allowed
    def is_genericDynAttr_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read WaveformDataFormat attribute
#------------------------------------------------------------------
    def read_WaveformDataFormat(self, attr):
        self.debug_stream("In %s::read_WaveformDataFormat()"%self.get_name())
        
        #    Add your own code here
        
        attr_WaveformDataFormat_read = self.__readAttributes[attr.get_name()]
        if not attr_WaveformDataFormat_read == float('-inf'):
            attr.set_value_date_quality(attr_WaveformDataFormat_read,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#------------------------------------------------------------------
#    Write WaveformDataFormat attribute
#------------------------------------------------------------------
    def write_WaveformDataFormat(self, attr):
        self.debug_stream("In %s::write_WaveformDataFormat()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_WaveformDataFormat(): Attribute value = %s"\
                          %(self.get_name(),data[0]))

        #    Add your own code here
        scpi = self.instructionSet.send("WaveformDataFormat",value=data[0])
        try:
            self.write(scpi)
            self.__readAttributes['WaveformDataFormat'] = self.ask(self.instructionSet.query("WaveformDataFormat"))
            self.__readAttributes['WaveformDataFormat_timestamp'] = time.time()
        except:
            pass


#---- WaveformDataFormat attribute State Machine -----------------
    def is_WaveformDataFormat_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read AcquisitionMode attribute
#------------------------------------------------------------------
    def read_AcquisitionMode(self, attr):
        self.debug_stream("In %s::read_AcquisitionMode()"%self.get_name())
        
        #    Add your own code here
        attr_AcquisitionMode_read = self.__readAttributes[attr.get_name()]
        if not attr_AcquisitionMode_read == float('-inf'):
            attr.set_value_date_quality(attr_AcquisitionMode_read,\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#------------------------------------------------------------------
#    Write AcquisitionMode attribute
#------------------------------------------------------------------
    def write_AcquisitionMode(self, attr):
        self.debug_stream("In %s::write_AcquisitionMode()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_AcquisitionMode(): Attribute value = %s"\
                          %(self.get_name(),data[0]))

        #    Add your own code here
        if not data[0].lower() in ['rtime','pdetect','hresolution','segmented']:
            raise AttributeError,"Not supported by this manufacturer and/or model"
        scpi = self.instructionSet.send("AcquisitionMode",value=data[0])
        try:
            self.write(scpi)
            self.__readAttributes['AcquisitionMode'] = self.ask(self.instructionSet.query("AcquisitionMode"))
            self.__readAttributes['AcquisitionMode_timestamp'] = time.time()
        except:
            pass


#---- AcquisitionMode attribute State Machine -----------------
    def is_AcquisitionMode_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Read AcquisitionPoints attribute
#------------------------------------------------------------------
    def read_AcquisitionPoints(self, attr):
        self.debug_stream("In %s::read_AcquisitionPoints()"%self.get_name())
        
        #    Add your own code here
        attr_AcquisitionPoints_read = self.__readAttributes[attr.get_name()]
        if not attr_AcquisitionPoints_read == float('-inf'):
            if attr_AcquisitionPoints_read.lower() == 'auto':
                attr_AcquisitionPoints_read = '-1'
            attr.set_value_date_quality(int(attr_AcquisitionPoints_read),\
                                        self.__readAttributes[attr.get_name()+"_timestamp"],\
                                        PyTango.AttrQuality.ATTR_VALID)
        else:
            raise AttributeError,"Not supported by this manufacturer and/or model"


#------------------------------------------------------------------
#    Write AcquisitionPoints attribute
#------------------------------------------------------------------
    def write_AcquisitionPoints(self, attr):
        self.debug_stream("In %s::write_AcquisitionPoints()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_AcquisitionPoints(): Attribute value = %s"\
                          %(self.get_name(),data[0]))

        #    Add your own code here
        if int(data[0]) < 0: data[0] = 'auto'
        scpi = self.instructionSet.send("AcquisitionPoints",value=data[0])
        try:
            self.write(scpi)
            self.__readAttributes['AcquisitionPoints'] = self.ask(self.instructionSet.query("AcquisitionPoints"))
            self.__readAttributes['AcquisitionPoints_timestamp'] = time.time()
        except:
            pass


#---- AcquisitionPoints attribute State Machine -----------------
    def is_AcquisitionPoints_allowed(self, req_type):
        if self.get_state() in [PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#==================================================================
#
#    Scope command methods
#
#==================================================================

#------------------------------------------------------------------
#    Reset command:
#
#    Description: 
#------------------------------------------------------------------
    def Reset(self):
        self.debug_stream("In %s::Reset()"%self.get_name())
        #    Add your own code here
        self.stopThread()
        self.__visaScope = None
        self.startThread(1)


#------------------------------------------------------------------
#    Start command:
#
#    Description: 
#------------------------------------------------------------------
    def Start(self):
        self.debug_stream("In %s::Start()"%self.get_name())
        #    Add your own code here
        self.startThread(1)
        self.__checkOpenChannels()
        self.set_state(PyTango.DevState.ON)
        self.exceptionStatus()


#------------------------------------------------------------------
#    Stop command:
#
#    Description: 
#------------------------------------------------------------------
    def Stop(self):
        self.debug_stream("In %s::Stop()"%self.get_name())
        #    Add your own code here
        self.stopThread()
        self.set_state(PyTango.DevState.OFF)
        self.exceptionStatus()
        for ch in self.isChannelOpen:
            self.isChannelOpen[ch] = False


#------------------------------------------------------------------
#    Lock command:
#
#    Description: 
#------------------------------------------------------------------
    def Lock(self):
        self.debug_stream("In %s::Lock()"%self.get_name())
        #    Add your own code here
        self.write(self.instructionSet.send("lock",value=True))


#---- Lock command State Machine -----------------
    def is_Lock_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Unlock command:
#
#    Description: 
#------------------------------------------------------------------
    def Unlock(self):
        self.debug_stream("In %s::Unlock()"%self.get_name())
        #    Add your own code here
        self.write(self.instructionSet.send("lock",value=False))


#---- Unlock command State Machine -----------------
    def is_Unlock_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    IDN command:
#
#    Description: 
#    argout: DevString
#------------------------------------------------------------------
    def IDN(self):
        self.debug_stream("In %s::IDN()"%self.get_name())
        #    Add your own code here
        
        try:
            return self.idn
        except:
            self.idn = self.ask("*IDN?")
            return self.idn


#------------------------------------------------------------------
#    CMD command:
#
#    Description: 
#    argin:  DevString    
#    argout: DevString    
#------------------------------------------------------------------
    def CMD(self, argin):
        self.debug_stream("In %s::CMD()"%self.get_name())
        #    Add your own code here
        argin = str(argin)
        self.info_stream("In %s::CMD(\"%s\")"%(self.get_name(),argin))
        if argin.find('?') >= 0:
            return self.ask(argin)
        else:
            self.write(argin)
            return ""


#------------------------------------------------------------------
#    CMDfloat command:
#
#    Description: 
#    argin:  DevString    
#    argout: DevVarFloatArray    
#------------------------------------------------------------------
    def CMDfloat(self, argin):
        self.debug_stream("In %s::CMDfloat()"%self.get_name())
        #    Add your own code here
        argin = str(argin)
        self.info_stream("In %s::CMDfloat(\"%s\")"%(self.get_name(),argin))
        if argin.find('?') >= 0:
            return self.ask_for_values(argin)
        else:
            self.write(argin)
            return "NaN"


#------------------------------------------------------------------
#    OpenCh command:
#
#    Description: 
#    argin:  DevUShort    
#------------------------------------------------------------------
    def OpenCh(self, argin):
        self.debug_stream("In %s::OpenCh()"%self.get_name())
        #    Add your own code here
        #self.write(self.instructionSet.send("channelDisplay",argin,'on'))
        self.write(self.instructionSet.query("channelDisplay",int(argin))[:-1]+' on')
        _channelDisplay = self.ask(self.instructionSet.query("channelDisplay",\
                                                             argin))
        self.isChannelOpen[int(argin)] = bool(int(_channelDisplay))


#------------------------------------------------------------------
#    CloseCh command:
#
#    Description: 
#    argin:  DevUShort
#------------------------------------------------------------------
    def CloseCh(self, argin):
        self.debug_stream("In %s::CloseCh()"%self.get_name())
        #    Add your own code here
        #self.write(self.instructionSet.send("channelDisplay",int(argin),' off'))
        self.write(self.instructionSet.query("channelDisplay",int(argin))[:-1]+' off')
        _channelDisplay = self.ask(self.instructionSet.query("channelDisplay",\
                                                             argin))
        self.isChannelOpen[int(argin)] = bool(int(_channelDisplay))


#------------------------------------------------------------------
#    OpenFn command:
#
#    Description: 
#    argin:  DevUShort    
#------------------------------------------------------------------
    def OpenFn(self, argin):
        self.debug_stream("In %s::OpenFn()"%self.get_name())
        #    Add your own code here
        #self.write(self.instructionSet.send("functionDisplay",argin,'on'))
        self.write(self.instructionSet.query("functionDisplay",int(argin))[:-1]+' on')
        _functionDisplay = self.ask(self.instructionSet.query("functionDisplay",\
                                                              argin))
        self.isFunctionOn[int(argin)] = bool(int(_functionDisplay))


#------------------------------------------------------------------
#    CloseFn command:
#
#    Description: 
#    argin:  DevUShort
#------------------------------------------------------------------
    def CloseFn(self, argin):
        self.debug_stream("In %s::CloseFn()"%self.get_name())
        #    Add your own code here
        #self.write(self.instructionSet.send("functionDisplay",argin,'off'))
        self.write(self.instructionSet.query("functionDisplay",int(argin))[:-1]+' off')
        _functionDisplay = self.ask(self.instructionSet.query("functionDisplay",\
                                                              argin))
        self.isFunctionOn[int(argin)] = bool(int(_functionDisplay))


#==================================================================
#
#    ScopeClass class definition
#
#==================================================================
class ScopeClass(PyTango.DeviceClass):
#class ScopeClass(DynamicDSClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'NumChannels':
            [PyTango.DevShort,
            "This information is used to generate dynamically the number of spaces will be in much of the spectrum values.",
            [] ],
        'NumFunctions':
            [PyTango.DevShort,
            "This will setup the number of function channels supported by the scope. It's 0 by default.",
            [ 0 ] ],
        'PyVisaDS':
            [PyTango.DevString,
            "The tango name of the PyVisaDS who is connected to the oscilloscope.",
            [] ],
        'logger_maxlen':
            [PyTango.DevLong,
            "A positive number to tune the number of characters of data to throw on the log file.",
            [] ],
        'LockInstrument':
            [PyTango.DevBoolean,
            "Lock the front panel of the instrument on the device start up.",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'Reset':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Start':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Stop':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Lock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Unlock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'IDN':
            [[PyTango.DevVoid, ""],
            [PyTango.DevString, ""]],
        'CMD':
            [[PyTango.DevString, ""],
            [PyTango.DevString, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'CMDfloat':
            [[PyTango.DevString, ""],
            [PyTango.DevVarFloatArray, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        'OpenCh':
            [[PyTango.DevUShort, ""],
            [PyTango.DevVoid, ""]],
        'CloseCh':
            [[PyTango.DevUShort, ""],
            [PyTango.DevVoid, ""]],
        'OpenFn':
            [[PyTango.DevUShort, ""],
            [PyTango.DevVoid, ""]],
        'CloseFn':
            [[PyTango.DevUShort, ""],
            [PyTango.DevVoid, ""]],
        }


    #    Attribute definitions
    attr_list = {
        'ScaleH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"time scale",
                'unit':"seconds",
                'format':"%2.6f",
                'description':"The time scale per division. This use the International system units (but it can work in the order of microseconds (or the accuracy that the oscilloscope allows)).",
            } ],
        'OffsetH':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
                'label':"time offset",
                'unit':"seconds",
                'format':"%2.6f",
                'description':"Delay between the trigger time and the reference point. This use the International system units (but it can work in the order of microseconds (or the accuracy that the oscilloscope allows)).",
            } ],
        'CurrentSampleRate':
            [[PyTango.DevDouble,
            PyTango.SCALAR,
            PyTango.READ]],
        'TriggerType':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ]],
#        'WaveformFormat':
#            [[PyTango.DevString,
#            PyTango.SCALAR,
#            PyTango.READ_WRITE],
#            {
#             'Display level':PyTango.DispLevel.EXPERT,
#            }],
        'QueryWindow':
            [[PyTango.DevUShort,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
             'Memorized':"true",#_without_hard_applied",
             'Display level':PyTango.DispLevel.EXPERT,
             'description':"When many attributes are requested at the same time, they are grouped in subqueries of this size",
             'label':"Query Window",
             'unit':"queries",
             'format':'%2d',
             #'max value':8,
             #'min value':1,
            }],
        'TimeStampsThreshold':
            [[PyTango.DevFloat,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
             'Memorized':"true",
             'Display level':PyTango.DispLevel.EXPERT,
             'description':"This value sets the threshold time to use a cached value or hardware read it",
             'label':"Time stamps Threshold",
             'unit':'seconds',
             'format':'%3.2g',
             'max value':3,
             'min value':0.1,
            }],
        'WaveformDataFormat':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
             'Memorized':"true",
             'Display level':PyTango.DispLevel.EXPERT,
             'description':"Waveform data transmition mode {ascii|byte|word|long}",
             'label':"Channel Format",
            }],
        'AcquisitionMode':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
             'Display level':PyTango.DispLevel.EXPERT,
             'description':"Scope sampling mode {RTIMe|PDETect|HRESolution|SEGMented}",
             'label':"Acquisition Mode",
            }],
        'AcquisitionPoints':
            [[PyTango.DevLong,
            PyTango.SCALAR,
            PyTango.READ_WRITE],
            {
             'Display level':PyTango.DispLevel.EXPERT,
             'description':"Requested memory depth for an acquisition, in points",
             'label':"Acquisition Points",
            }],
        }


#------------------------------------------------------------------
#    ScopeClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In ScopeClass  constructor"

    def dyn_attr(self, dev_list):
        for dev in dev_list:
            dev.dyn_attr()

#==================================================================
#
#    Scope class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(ScopeClass,Scope,'Scope')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> Received an Exception:',e
