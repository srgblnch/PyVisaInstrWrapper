#!/usr/bin/env python2.5

#=============================================================================
#
# file :        PyRealTimeSpectrum.py
#
# description : Python source for the RealTimeSpectrum and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                RealTimeSpectrum are implemented in this file.
#
# project :     TANGO Device Server
#
# Author: sblanch (first developer)
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    Cells / Alba Synchrotron
#               Cerdanyola/Bellaterra
#               Spain
#
#=============================================================================
#          This file is generated by POGO
#    (Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#
# This file is part of Tango-ds project.
#
# Tango-ds project is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# Tango-ds project is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#=============================================================================


import PyTango
import sys
import array

import remoteCommandsRTS
import threadVisa
from cStringIO import StringIO #For goodly fast str concat

class ScalarAttributeList(PyTango.Attr):
    pass


#==================================================================
#   RealTimeSpectrum Class Description:
#
#         A device server to manage a Realtime Spectrum Analyzers. Inicially work with the Tektronix RSA3300 Series. This device uses a PyVisa-ds as a bridge.
#
#==================================================================
#     Device States Description:
#
#   DevState.ON :       Well connected to the visa device
#   DevState.OFF :      Disconnected to the visa device
#   DevState.FAULT :    Something wrong on the communication with the visa device
#   DevState.DISABLE :  The visa device has no connectivity to the instrument
#==================================================================


class RealTimeSpectrum(PyTango.Device_4Impl,threadVisa.ThreadVisa):

#--------- Add you global variables here --------------------------

    def link2dict(self):
        try:
            #self.visaDict = containers.RankedThreadDict()
            self.idn = self.ask("*IDN?")
        except Exception,e:
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            self.fatal_stream("In %s::link2dict():IDN Exception: %s"\
                             %(self.get_name(),e))
            return
        try:
            company,model,serial,firmware = self.idn.split(",")
            self.info_stream("\nRealTimeSpectrum characteristics:\n"\
                              "\tManufacturer: %s\n"\
                              "\tModel: %s\n"\
                              "\tSerial: %s\n"\
                              "\tFirmware: %s"%(company,model,serial,firmware))
            self.instructionSet = {
                'tektronix': remoteCommandsRTS.Tektronix,
            }[company.lower()](debug=True)
        except Exception,e:
            self.error_stream("In %s::link2dict() Exception: %s"\
                              %(self.get_name(),e))
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus("The device has not been able to get the "\
                                 "instructions set (hint: if the manufacturer "\
                                 "is supported, check %s is exported and try "\
                                 "init this device)"%self.PyVisaDS)
            return
        try:
            if self.LockInstrument:
                self.Lock()
        except Exception,e:
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            self.warn_stream("In %s::link2dict() Exception %s"\
                              %(self.get_name(),e))

    def composeStatusString(self):
        msg = "The device is in %s state."%(self.get_state())
        msg += "\nThe instrument is %s"\
               %("LOCK" if bool(self.read(self.instructionSet.query("lock")))\
                        else "UNLOCK")
        self.set_status(msg)

#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,cl, name):
        PyTango.Device_4Impl.__init__(self,cl,name)
        self.__modes = []
        RealTimeSpectrum.init_device(self)

#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    def delete_device(self):
        self.info_stream("[Device delete_device method] for device %s"\
                          %self.get_name())


#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    def init_device(self):
        self.info_stream("In %s::init_device()"%(self.get_name()))
        self.set_state(PyTango.DevState.INIT)
        self.exceptionStatus()
        self.get_device_properties(self.get_device_class())
        #logger
        try:
            self.logger_maxlen = int(self.logger_maxlen)
            if self.logger_maxlen < 1: self.logger_maxlen = 1000
        except Exception,e:
            self.debug_stream("In %s::init_device():Invalid \"logger_maxlen\" "\
                              "property value. Setting to default "\
                              "logger_maxlen=1000"%self.get_name())
            self.warn_stream("In %s::init_device():Exception: %s"\
                              %(self.get_name(),e))
            self.logger_maxlen = 1000
        self.debug_stream("In %s::init_device():LOGGER_maxlen property set to "\
                          "%d"%(self.get_name(),self.logger_maxlen))
        #channels => no sense here
        #PyVisaDS
        self.info_stream("In %s::init_device():Property for the 'Remote "\
                          "PyVisa device' in set, connecting to the device "\
                          "%s"%(self.get_name(),self.PyVisaDS))
        #Lock
        try:
            self.LockInstrument = bool(self.LockInstrument)
            self.info_stream("In %s::init_device(): LockInstrument property "\
                             "= %s"%(self.get_name(),self.LockInstrument))
        except Exception,e:
            self.LockInstrument = True
            self.error_stream("In %s::init_device(): Invalid \"LockInstrument\""\
                              " property value. Setting to default, True"\
                              %(self.get_name()))
        #connect
        try:
            self.startThread(1)
        except Exception,e:
            self.fatal_stream("In %s::init_device():PyVisaDS not available. "\
                              "Exception: %s"%(self.get_name(),e))
            self.set_state(PyTango.DevState.FAULT)
            self.exceptionStatus(e)
            return

        #done
        self.set_state(PyTango.DevState.ON)
        self.exceptionStatus()

#------------------------------------------------------------------
#    Always excuted hook method
#------------------------------------------------------------------
    def always_executed_hook(self):
        self.debug_stream("In ", self.get_name(), "::always_excuted_hook()")

#==================================================================
#
#    RealTimeSpectrum read/write attribute methods
#
#==================================================================
#------------------------------------------------------------------
#    Read Attribute Hardware
#------------------------------------------------------------------
    def read_attr_hardware(self,data):
        self.debug_stream("In ", self.get_name(), "::read_attr_hardware()")


    def dyn_attr(self):
        self.debug_stream("In %s::dyn_attr()"%self.get_name())


#------------------------------------------------------------------
#    Read modes attribute
#------------------------------------------------------------------
    def read_modes(self, attr):
        self.debug_stream("In %s::read_modes()"%self.get_name())
        
        #    Add your own code here
        _modes = self.ask(self.instructionSet.query("modes")).replace('\"','')
        self.__modes = _modes.split(',')
        if not attr is None:
            attr.set_value(self.__modes)


#------------------------------------------------------------------
#    Read mode attribute
#------------------------------------------------------------------
    def read_mode(self, attr):
        self.debug_stream("In %s::read_mode()"%self.get_name())
        
        #    Add your own code here
        if len(self.__modes) == 0:
            self.read_modes(None)
        _mode = str(self.ask(self.instructionSet.query("mode"))).strip('"')
        if _mode in self.__modes:
            attr.set_value(_mode)
        else:
            self.debug_stream("%s is NOT in the list: %s"%(_mode,self.__modes))


#------------------------------------------------------------------
#    Write mode attribute
#------------------------------------------------------------------
    def write_mode(self, attr):
        self.debug_stream("In %s::write_mode()"%self.get_name())
        data=[]
        attr.get_write_value(data)
        self.debug_stream("In %s::write_mode():Attribute value = %s"\
                          %(self.get_name(),data))

        #    Add your own code here
        if self.__modes is []:
            self.read_modes(None)
        argin = str(data[0])
        if argin in self.__modes:
            _mode = str(self.ask(self.instructionSet.send("mode",value=argin)))
            attr.set_value(_mode)


#------------------------------------------------------------------
#    Read waveform attribute
#------------------------------------------------------------------
    def read_waveform(self, attr):
        self.debug_stream("In %s::read_waveform()"%self.get_name())
        
        #    Add your own code here
        wave_encoded = self.ask(self.instructionSet.query("waveform"))
        ## Structure of the answer:
        ## '#nNNNNNNN....'
        ## first character always is #
        ## second is a number [0,9] of digits of the next field, num_bytes,
        ##                    defining the number of elements are after it
        ## third is the number of bytes contained in the complete package of data.
        self.debug_stream("header mark = %s"%wave_encoded[0])
        if not wave_encoded[0] == "#":
            raise Exception("Invalid received data")
        try:
            self.debug_stream("header size = %s"%wave_encoded[1])
            wave_numbytes = int(wave_encoded[1])
        except Exception,e:
            self.error_stream("Error extracting the <num_digit> field:\n%s"%e)
        try:
            self.debug_stream("number of bytes = %s"\
                              %(wave_encoded[2:wave_numbytes+2]))
            numberElements = int(wave_encoded[2:wave_numbytes+2])
            elementsList = wave_encoded[wave_numbytes+2:]
        except Exception,e:
            self.error_stream("Error extracting the <num_bytes> field:\n%s"%e)
        elements = array.array('f',elementsList).tolist()
        attr.set_value(elements)


#------------------------------------------------------------------
#    Read spectrogram attribute
#------------------------------------------------------------------
    def read_spectrogram(self, attr):
        self.debug_stream("In %s::read_spectrogram()"%self.get_name())
        
        #    Add your own code here
        spectrogram_encoded = self.ask(self.instructionSet.query("spectrogram"))
        ## Structure of the answer:
        ## '#nNNNNNNN....'
        ## first character always is #
        ## second is a number [0,9] of digits of the next field, num_bytes,
        ##                     defining the number of elements are after it
        ## third is the number of bytes contained in the complete package of data.
        self.debug_stream("header mark = %s"%spectrogram_encoded[0])
        if not spectrogram_encoded[0] == "#":
            raise Exception("Invalid received data")
        try:
            self.debug_stream("header size = %s"%spectrogram_encoded[1])
            spectrogram_numbytes = int(spectrogram_encoded[1])
        except Exception,e:
            self.error_stream("Error extracting the <num_digit> field:\n%s"%e)
        try:
            self.debug_stream("number of bytes = %s"\
                              %(spectrogram_encoded[2:spectrogram_numbytes+2]))
            numberElements = int(spectrogram_encoded[2:spectrogram_numbytes+2])
            elementsList = spectrogram_encoded[spectrogram_numbytes+2:]
        except Exception,e:
            self.error_stream("Error extracting the <num_bytes> field:\n%s"%e)
        elements = array.array('f',elementsList).tolist()
        attr.set_value(elements)


#==================================================================
#
#    RealTimeSpectrum command methods
#
#==================================================================

#------------------------------------------------------------------
#    Reset command:
#
#    Description: 
#------------------------------------------------------------------
    def Reset(self):
        self.debug_stream("In ", self.get_name(), "::Reset()")
        #    Add your own code here
        self.stopThread()
        self.__visaScope = None
        self.startThread(1)


#---- Reset command State Machine -----------------
    def is_Reset_allowed(self):
        if self.get_state() in [PyTango.DevState.ON,
                                PyTango.DevState.OFF,
                                PyTango.DevState.DISABLE]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Start command:
#
#    Description: 
#------------------------------------------------------------------
    def Start(self):
        self.debug_stream("In ", self.get_name(), "::Start()")
        #    Add your own code here
        self.startThread(1)
        self.__checkOpenChannels()
        self.set_state(PyTango.DevState.ON)
        self.exceptionStatus()


#---- Start command State Machine -----------------
    def is_Start_allowed(self):
        if self.get_state() in [PyTango.DevState.ON,
                                PyTango.DevState.FAULT,
                                PyTango.DevState.DISABLE]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Stop command:
#
#    Description: 
#------------------------------------------------------------------
    def Stop(self):
        self.debug_stream("In ", self.get_name(), "::Stop()")
        #    Add your own code here
        self.stopThread()
        self.set_state(PyTango.DevState.OFF)
        self.exceptionStatus()


#---- Stop command State Machine -----------------
    def is_Stop_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Lock command:
#
#    Description: 
#------------------------------------------------------------------
    def Lock(self):
        self.debug_stream("In %s::Lock()"%self.get_name())
        #    Add your own code here
        self.write(self.instructionSet.send("lock",value=True))
        self.composeStatusString()


#---- Lock command State Machine -----------------
    def is_Lock_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    Unlock command:
#
#    Description: 
#------------------------------------------------------------------
    def Unlock(self):
        self.debug_stream("In %s::Unlock()"%self.get_name())
        #    Add your own code here
        self.write(self.instructionSet.send("lock",value=False))
        self.composeStatusString()


#---- Unlock command State Machine -----------------
    def is_Unlock_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    IDN command:
#
#    Description: 
#    argout: DevString    
#------------------------------------------------------------------
    def IDN(self):
        self.debug_stream("In ", self.get_name(), "::IDN()")
        #    Add your own code here
        self.idn = self.ask("*IDN?")
        return self.idn


#---- IDN command State Machine -----------------
    def is_IDN_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT,
                                PyTango.DevState.DISABLE]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


#------------------------------------------------------------------
#    CMD command:
#
#    Description: 
#    argin:  DevString    
#    argout: DevString    
#------------------------------------------------------------------
    def CMD(self, argin):
        self.debug_stream("In ", self.get_name(), "::CMD()")
        #    Add your own code here
        argin = str(argin)
        self.debug_stream("In %s::CMD(\"%s\")"%(self.get_name(),argin))
        if argin.find('?') >= 0:
            return self.ask(argin)
        else:
            self.write(argin)
            return ""


#---- CMD command State Machine -----------------
    def is_CMD_allowed(self):
        if self.get_state() in [PyTango.DevState.OFF,
                                PyTango.DevState.FAULT,
                                PyTango.DevState.DISABLE]:
            #    End of Generated Code
            #    Re-Start of Generated Code
            return False
        return True


##------------------------------------------------------------------
##    OpenCh command:
##
##    Description: 
##    argin:  DevShort    
##------------------------------------------------------------------
#    def OpenCh(self, argin):
#        self.debug_stream("In %s::OpenCh()"%self.get_name())
#        #    Add your own code here
#
#
##---- OpenCh command State Machine -----------------
#    def is_OpenCh_allowed(self):
#        if self.get_state() in [PyTango.DevState.OFF,
#                                PyTango.DevState.FAULT,
#                                PyTango.DevState.DISABLE]:
#            #    End of Generated Code
#            #    Re-Start of Generated Code
#            return False
#        return True


##------------------------------------------------------------------
##    CloseCh command:
##
##    Description: 
##    argin:  DevShort    
##------------------------------------------------------------------
#    def CloseCh(self, argin):
#        self.debug_stream("In %s::CloseCh()"%self.get_name())
#        #    Add your own code here
#
#
##---- CloseCh command State Machine -----------------
#    def is_CloseCh_allowed(self):
#        if self.get_state() in [PyTango.DevState.OFF,
#                                PyTango.DevState.FAULT,
#                                PyTango.DevState.DISABLE]:
#            #    End of Generated Code
#            #    Re-Start of Generated Code
#            return False
#        return True


##------------------------------------------------------------------
##    ChannelState command:
##
##    Description: 
##    argout: DevBoolean    
##------------------------------------------------------------------
#    def ChannelState(self):
#        self.debug_stream("In %s::ChannelState()"%self.get_name())
#        #    Add your own code here
#        
#        return argout
#
#
##---- ChannelState command State Machine -----------------
#    def is_ChannelState_allowed(self):
#        if self.get_state() in [PyTango.DevState.OFF,
#                                PyTango.DevState.FAULT,
#                                PyTango.DevState.DISABLE]:
#            #    End of Generated Code
#            #    Re-Start of Generated Code
#            return False
#        return True


#==================================================================
#
#    RealTimeSpectrumClass class definition
#
#==================================================================
class RealTimeSpectrumClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'PyVisaDS':
            [PyTango.DevString,
            "The tango name of the PyVisaDS who is connected to the oscilloscope.",
            [] ],
        'logger_maxlen':
            [PyTango.DevLong,
            "A positive number to tune the number of characters of data to throw on the log file.\"",
            [] ],
        'LockInstrument':
            [PyTango.DevBoolean,
            "Lock the front panel of the instrument on the device start up.",
            [] ],
        }


    #    Command definitions
    cmd_list = {
        'Reset':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Start':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Stop':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Lock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'Unlock':
            [[PyTango.DevVoid, ""],
            [PyTango.DevVoid, ""]],
        'IDN':
            [[PyTango.DevVoid, ""],
            [PyTango.DevString, ""]],
        'CMD':
            [[PyTango.DevString, ""],
            [PyTango.DevString, ""],
            {
                'Display level':PyTango.DispLevel.EXPERT,
             } ],
        }


    #    Attribute definitions
    attr_list = {
        'modes':
            [[PyTango.DevString,
            PyTango.SPECTRUM,
            PyTango.READ,10]],
        'mode':
            [[PyTango.DevString,
            PyTango.SCALAR,
            PyTango.READ_WRITE]],
        'waveform':
            [[PyTango.DevDouble,
            PyTango.SPECTRUM,
            PyTango.READ,1000000]],
        'spectrogram':
            [[PyTango.DevDouble,
            PyTango.IMAGE,
            PyTango.READ,1000,1000]],

        }


#------------------------------------------------------------------
#    RealTimeSpectrumClass Constructor
#------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name);
        print "In RealTimeSpectrumClass  constructor"

    def dyn_attr(self, dev_list):
        for dev in dev_list:
            dev.dyn_attr()

#==================================================================
#
#    RealTimeSpectrum class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(RealTimeSpectrumClass,RealTimeSpectrum,'RealTimeSpectrum')

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
